import json
import os
import random
from collections import Counter
from telegram import Update, ReplyKeyboardMarkup, InlineKeyboardButton, InlineKeyboardMarkup, InputMediaPhoto
from telegram.ext import (
    Application,
    CommandHandler,
    MessageHandler,
    CallbackQueryHandler,
    filters,
    CallbackContext,
    ConversationHandler,
)
import shutil

TOKEN = 'YOUR_TOKEN'


# –ö–ª–∞—Å—Å –¥–ª—è –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–π
class PhotoDatabase:
    def __init__(self, filename='photos.json'):
        self.filename = filename
        self.data = []
        self.load_data()

    def load_data(self):
        if os.path.exists(self.filename):
            with open(self.filename, 'r') as f:
                self.data = json.load(f)

    def save_data(self):
        with open(self.filename, 'w') as f:
            json.dump(self.data, f, indent=4)

    def add_entry(self, file_path, authors, tags, characters):
        # –°–æ—Ä—Ç–∏—Ä—É–µ–º —Å–ø–∏—Å–∫–∏ –ø–æ –∞–ª—Ñ–∞–≤–∏—Ç—É
        sorted_authors = sorted([author.strip() for author in authors], key=lambda x: x.lower())
        sorted_tags = sorted([tag.strip() for tag in tags], key=lambda x: x.lower())
        sorted_characters = sorted([character.strip() for character in characters], key=lambda x: x.lower())

        # –î–æ–±–∞–≤–ª—è–µ–º –∑–∞–ø–∏—Å—å
        entry = {
            'id': len(self.data) + 1,  # –£–Ω–∏–∫–∞–ª—å–Ω—ã–π ID
            'file_path': file_path,
            'authors': sorted_authors,
            'tags': sorted_tags,
            'characters': sorted_characters
        }
        self.data.append(entry)
        self.data.sort(key=lambda x: x['id'])  # –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ ID
        self.save_data()

    def update_entry(self, entry_id, new_authors=None, new_tags=None, new_characters=None):
        for entry in self.data:
            if entry['id'] == int(entry_id):
                # –û–±–Ω–æ–≤–ª—è–µ–º –∞–≤—Ç–æ—Ä–æ–≤, –µ—Å–ª–∏ –ø–µ—Ä–µ–¥–∞–Ω—ã
                if new_authors:
                    new_authors = [author.strip() for author in new_authors if author.strip()]
                    entry['authors'] = sorted(list(set(entry['authors'] + new_authors)), key=lambda x: x.lower())

                # –û–±–Ω–æ–≤–ª—è–µ–º —Ç–µ–≥–∏
                if new_tags:
                    new_tags = [tag.strip() for tag in new_tags if tag.strip()]
                    entry['tags'] = sorted(list(set(entry['tags'] + new_tags)), key=lambda x: x.lower())

                # –û–±–Ω–æ–≤–ª—è–µ–º –ø–µ—Ä—Å–æ–Ω–∞–∂–µ–π
                if new_characters:
                    new_characters = [character.strip() for character in new_characters if character.strip()]
                    entry['characters'] = sorted(list(set(entry['characters'] + new_characters)),
                                                 key=lambda x: x.lower())

                break
        self.data.sort(key=lambda x: x['id'])
        self.save_data()

    def search_by_author(self, author):
        return [entry for entry in self.data if any(author.lower() == a.lower() for a in entry['authors'])]

    def search_by_tag(self, tag):
        return [entry for entry in self.data if any(tag.lower() in t.lower() for t in entry['tags'])]

    def search_by_character(self, character):
        return [entry for entry in self.data if any(character.lower() in c.lower() for c in entry['characters'])]

    def get_entries(self):
        return sorted(self.data, key=lambda x: x['id'])

    def get_all_authors(self):
        authors = set()
        for entry in self.data:
            for author in entry['authors']:
                authors.add(author)
        return sorted(list(authors), key=lambda x: x.lower())


# –°–æ–∑–¥–∞–µ–º —ç–∫–∑–µ–º–ø–ª—è—Ä –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
db = PhotoDatabase()

# –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏—è –¥–ª—è ConversationHandler
ADD_PHOTO, ADD_AUTHORS, ADD_TAGS, ADD_CHARACTERS = range(4)
UPDATE_ID, UPDATE_AUTHORS, UPDATE_TAGS, UPDATE_CHARACTERS = range(4, 8)


# –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –º–µ–Ω—é –∫–æ–º–∞–Ω–¥
def create_command_menu():
    command_menu = [
        ["/add‚ûï", "/update‚¨ÜÔ∏è"],
        ["/search_authorüë§", "/search_tagüîñ"],
        ["/search_characterüë•", "/displayüì±"],
        ["/helpüÜò"]
    ]
    return ReplyKeyboardMarkup(command_menu, resize_keyboard=True, one_time_keyboard=True)


# –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –∏–Ω–ª–∞–π–Ω-–∫–Ω–æ–ø–æ–∫ –¥–ª—è –ø—Ä–æ–ª–∏—Å—Ç—ã–≤–∞–Ω–∏—è
def create_navigation_buttons(current_index, total, prefix=None):
    keyboard = []
    if current_index > 0:
        keyboard.append(InlineKeyboardButton("‚¨ÖÔ∏è –ü—Ä–µ–¥—ã–¥—É—â–∞—è", callback_data=f"{prefix or ''}prev_{current_index}"))
    if current_index < total - 1:
        keyboard.append(InlineKeyboardButton("–°–ª–µ–¥—É—é—â–∞—è ‚û°Ô∏è", callback_data=f"{prefix or ''}next_{current_index}"))
    return InlineKeyboardMarkup([keyboard] if keyboard else [])


# –ö–æ–º–∞–Ω–¥–∞ /start
async def start(update: Update, context: CallbackContext) -> None:
    await update.message.reply_text(
        "üåü <b>–ü—Ä–∏–≤–µ—Ç! –Ø –±–æ—Ç –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –±–∞–∑–æ–π –¥–∞–Ω–Ω—ã—Ö —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–π.</b>\n\n"
        "–ò—Å–ø–æ–ª—å–∑—É–π –∫–æ–º–∞–Ω–¥—ã:\n"
        "/add - –î–æ–±–∞–≤–∏—Ç—å –Ω–æ–≤—É—é —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏—é\n"
        "/update - –û–±–Ω–æ–≤–∏—Ç—å –∑–∞–ø–∏—Å—å\n"
        "/search_author - –ù–∞–π—Ç–∏ –ø–æ –∞–≤—Ç–æ—Ä—É\n"
        "/search_tag - –ù–∞–π—Ç–∏ –ø–æ —Ç–µ–≥—É\n"
        "/search_character - –ù–∞–π—Ç–∏ –ø–æ –ø–µ—Ä—Å–æ–Ω–∞–∂—É\n"
        "/display - –ü–æ–∫–∞–∑–∞—Ç—å –≤—Å–µ –∑–∞–ø–∏—Å–∏\n"
        "/help - –ü–æ–∫–∞–∑–∞—Ç—å —Å–ø–∏—Å–æ–∫ –∫–æ–º–∞–Ω–¥",
        parse_mode="HTML",
        reply_markup=create_command_menu()
    )


# –ö–æ–º–∞–Ω–¥–∞ /add
async def add_entry(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text("üì∏ –û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏—é:")
    return ADD_PHOTO


async def add_photo(update: Update, context: CallbackContext) -> int:
    if not update.message.photo:
        await update.message.reply_text("‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏—é.")
        return ADD_PHOTO
    photo = update.message.photo[-1]  # –ë–µ—Ä–µ–º —Ñ–æ—Ç–æ –Ω–∞–∏–±–æ–ª—å—à–µ–≥–æ —Ä–∞–∑–º–µ—Ä–∞
    file = await context.bot.get_file(photo.file_id)
    file_path = f"photos/{photo.file_unique_id}.jpg"
    os.makedirs('photos', exist_ok=True)  # –°–æ–∑–¥–∞–µ–º –ø–∞–ø–∫—É, –µ—Å–ª–∏ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
    await file.download_to_drive(file_path)
    context.user_data['file_path'] = file_path
    await update.message.reply_text("üë§ –í–≤–µ–¥–∏—Ç–µ –∞–≤—Ç–æ—Ä–∞ (—á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é, –µ—Å–ª–∏ –Ω–µ—Å–∫–æ–ª—å–∫–æ):")
    return ADD_AUTHORS


async def add_authors(update: Update, context: CallbackContext) -> int:
    context.user_data['authors'] = [author.strip() for author in update.message.text.split(',')]
    await update.message.reply_text("üè∑Ô∏è –í–≤–µ–¥–∏—Ç–µ —Ç–µ–≥–∏ (—á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é):")
    return ADD_TAGS


async def add_tags(update: Update, context: CallbackContext) -> int:
    context.user_data['tags'] = [tag.strip() for tag in update.message.text.split(',')]
    await update.message.reply_text("üë• –í–≤–µ–¥–∏—Ç–µ –ø–µ—Ä—Å–æ–Ω–∞–∂–µ–π (—á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é):")
    return ADD_CHARACTERS


async def add_characters(update: Update, context: CallbackContext) -> int:
    context.user_data['characters'] = [character.strip() for character in update.message.text.split(',')]
    db.add_entry(
        context.user_data['file_path'],
        context.user_data['authors'],
        context.user_data['tags'],
        context.user_data['characters']
    )
    # --- NEW: Copy to author folders and duplicate main folder ---
    file_path = context.user_data['file_path']
    authors = context.user_data['authors']
    if authors:
        for author in authors:
            author_folder = os.path.join('photos_by_author', author)
            os.makedirs(author_folder, exist_ok=True)
            shutil.copy2(file_path, os.path.join(author_folder, os.path.basename(file_path)))
    # Duplicate main folder
    if os.path.exists('photos_backup'):
        shutil.rmtree('photos_backup')
    shutil.copytree('photos', 'photos_backup')
    # --- END NEW ---
    await update.message.reply_text("‚úÖ –§–æ—Ç–æ–≥—Ä–∞—Ñ–∏—è –¥–æ–±–∞–≤–ª–µ–Ω–∞!", parse_mode="HTML")
    return ConversationHandler.END


# –ö–æ–º–∞–Ω–¥–∞ /update
async def update_entry(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text("–í–≤–µ–¥–∏—Ç–µ ID –∑–∞–ø–∏—Å–∏, –∫–æ—Ç–æ—Ä—É—é —Ö–æ—Ç–∏—Ç–µ –æ–±–Ω–æ–≤–∏—Ç—å:")
    return UPDATE_ID


async def update_id(update: Update, context: CallbackContext) -> int:
    try:
        entry_id = int(update.message.text)
        if not any(entry['id'] == entry_id for entry in db.data):
            await update.message.reply_text("‚ùå –ó–∞–ø–∏—Å—å —Å —Ç–∞–∫–∏–º ID –Ω–µ –Ω–∞–π–¥–µ–Ω–∞. –í–≤–µ–¥–∏—Ç–µ –¥—Ä—É–≥–æ–π ID:")
            return UPDATE_ID
        context.user_data['id'] = entry_id
        await update.message.reply_text(
            "–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤—ã—Ö –∞–≤—Ç–æ—Ä–æ–≤ (—á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é, –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ /skip, —á—Ç–æ–±—ã –æ—Å—Ç–∞–≤–∏—Ç—å —Å—Ç–∞—Ä—ã—Ö):")
        return UPDATE_AUTHORS
    except ValueError:
        await update.message.reply_text("‚ùå –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ–≤–æ–π ID:")
        return UPDATE_ID


async def update_authors(update: Update, context: CallbackContext) -> int:
    if update.message.text != "/skip":
        context.user_data['new_authors'] = [author.strip() for author in update.message.text.split(',')]
    await update.message.reply_text("–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤—ã–µ —Ç–µ–≥–∏ (—á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é, –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ /skip, —á—Ç–æ–±—ã –æ—Å—Ç–∞–≤–∏—Ç—å —Å—Ç–∞—Ä—ã–µ):")
    return UPDATE_TAGS


async def update_authors_skip(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text("–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤—ã–µ —Ç–µ–≥–∏ (—á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é, –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ /skip, —á—Ç–æ–±—ã –æ—Å—Ç–∞–≤–∏—Ç—å —Å—Ç–∞—Ä—ã–µ):")
    return UPDATE_TAGS


async def update_tags(update: Update, context: CallbackContext) -> int:
    if update.message.text != "/skip":
        context.user_data['new_tags'] = [tag.strip() for tag in update.message.text.split(',')]
    await update.message.reply_text(
        "–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤—ã—Ö –ø–µ—Ä—Å–æ–Ω–∞–∂–µ–π (—á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é, –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ /skip, —á—Ç–æ–±—ã –æ—Å—Ç–∞–≤–∏—Ç—å —Å—Ç–∞—Ä—ã—Ö):")
    return UPDATE_CHARACTERS


async def update_tags_skip(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤—ã—Ö –ø–µ—Ä—Å–æ–Ω–∞–∂–µ–π (—á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é, –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ /skip, —á—Ç–æ–±—ã –æ—Å—Ç–∞–≤–∏—Ç—å —Å—Ç–∞—Ä—ã—Ö):")
    return UPDATE_CHARACTERS


async def update_characters(update: Update, context: CallbackContext) -> int:
    if update.message.text != "/skip":
        context.user_data['new_characters'] = [character.strip() for character in update.message.text.split(',')]
    db.update_entry(
        context.user_data['id'],
        new_authors=context.user_data.get('new_authors'),
        new_tags=context.user_data.get('new_tags'),
        new_characters=context.user_data.get('new_characters')
    )
    await update.message.reply_text("‚úÖ –ó–∞–ø–∏—Å—å –æ–±–Ω–æ–≤–ª–µ–Ω–∞!", parse_mode="HTML")
    return ConversationHandler.END


async def update_characters_skip(update: Update, context: CallbackContext) -> int:
    db.update_entry(
        context.user_data['id'],
        new_authors=context.user_data.get('new_authors'),
        new_tags=context.user_data.get('new_tags'),
        new_characters=context.user_data.get('new_characters')
    )
    await update.message.reply_text("‚úÖ –ó–∞–ø–∏—Å—å –æ–±–Ω–æ–≤–ª–µ–Ω–∞!", parse_mode="HTML")
    return ConversationHandler.END


# –ö–æ–º–∞–Ω–¥–∞ /search_author
async def search_author(update: Update, context: CallbackContext) -> int:
    authors = db.get_all_authors()
    if not authors:
        await update.message.reply_text("‚ùå –í –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö –Ω–µ—Ç –∞–≤—Ç–æ—Ä–æ–≤.")
        return ConversationHandler.END
    random_authors = random.sample(authors, min(3, len(authors)))
    text_lines = []
    keyboard = []
    for idx, author in enumerate(random_authors, 1):
        entries = db.search_by_author(author)
        tags = [tag for entry in entries for tag in entry['tags']]
        tag_counts = Counter(tags)
        top_tags = ', '.join([f"#{t}" for t, _ in tag_counts.most_common(3)])
        line = f"{idx}. {author}"
        if top_tags:
            line += f" ‚Äî {top_tags}"
        text_lines.append(line)
        keyboard.append([InlineKeyboardButton(f"{author}", callback_data=f"authorselect_{author}")])
    text = "\n".join(text_lines)
    text += "\n\n–í—ã–±–µ—Ä–∏—Ç–µ –∞–≤—Ç–æ—Ä–∞, –Ω–∞–∂–∞–≤ –Ω–∞ –∫–Ω–æ–ø–∫—É, –∏–ª–∏ –≤–≤–µ–¥–∏—Ç–µ –∏–º—è –∞–≤—Ç–æ—Ä–∞ –≤—Ä—É—á–Ω—É—é:"
    await update.message.reply_text(text)
    return 0


async def search_author_result(update: Update, context: CallbackContext) -> int:
    author = update.message.text
    results = db.search_by_author(author)
    if results:
        context.user_data['search_results'] = results
        context.user_data['search_index'] = 0
        entry = results[0]
        caption = (
            f"<b>ID:</b> {entry['id']}\n"
            f"<b>üë§ –ê–≤—Ç–æ—Ä—ã:</b> {', '.join(entry['authors'])}\n"
            f"<b>üè∑Ô∏è –¢–µ–≥–∏:</b> {', '.join(entry['tags'])}\n"
            f"<b>üë• –ü–µ—Ä—Å–æ–Ω–∞–∂–∏:</b> {', '.join(entry['characters'])}"
        )
        try:
            await update.message.reply_photo(
                photo=open(entry['file_path'], 'rb'),
                caption=caption,
                parse_mode="HTML",
                reply_markup=create_navigation_buttons(0, len(results), prefix='author')
            )
        except FileNotFoundError:
            await update.message.reply_text(f"‚ùå –§–æ—Ç–æ–≥—Ä–∞—Ñ–∏—è —Å ID {entry['id']} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ.")
    else:
        await update.message.reply_text(f"‚ùå –ó–∞–ø–∏—Å–µ–π —Å –∞–≤—Ç–æ—Ä–æ–º '{author}' –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.")
    return ConversationHandler.END


# –ö–æ–º–∞–Ω–¥–∞ /search_tag
async def search_tag(update: Update, context: CallbackContext) -> None:
    await update.message.reply_text("üîç –í–≤–µ–¥–∏—Ç–µ —Ç–µ–≥ –¥–ª—è –ø–æ–∏—Å–∫–∞:")
    return "search_tag"


async def search_tag_result(update: Update, context: CallbackContext) -> int:
    tag = update.message.text
    results = db.search_by_tag(tag)
    if results:
        context.user_data['search_results'] = results
        context.user_data['search_index'] = 0
        entry = results[0]
        caption = (
            f"<b>ID:</b> {entry['id']}\n"
            f"<b>üë§ –ê–≤—Ç–æ—Ä—ã:</b> {', '.join(entry['authors'])}\n"
            f"<b>üè∑Ô∏è –¢–µ–≥–∏:</b> {', '.join(entry['tags'])}\n"
            f"<b>üë• –ü–µ—Ä—Å–æ–Ω–∞–∂–∏:</b> {', '.join(entry['characters'])}"
        )
        try:
            await update.message.reply_photo(
                photo=open(entry['file_path'], 'rb'),
                caption=caption,
                parse_mode="HTML",
                reply_markup=create_navigation_buttons(0, len(results), prefix='tag')
            )
        except FileNotFoundError:
            await update.message.reply_text(f"‚ùå –§–æ—Ç–æ–≥—Ä–∞—Ñ–∏—è —Å ID {entry['id']} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ.")
    else:
        await update.message.reply_text(f"‚ùå –ó–∞–ø–∏—Å–µ–π —Å —Ç–µ–≥–æ–º '{tag}' –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.")


async def tag_button_handler(update: Update, context: CallbackContext) -> None:
    query = update.callback_query
    await query.answer()
    results = context.user_data.get('search_results', [])
    if not results:
        await query.edit_message_text("‚ùå –û—à–∏–±–∫–∞: —Å–ø–∏—Å–æ–∫ –∑–∞–ø–∏—Å–µ–π –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω.")
        return
    current_index = context.user_data.get('search_index', 0)
    callback_data = query.data
    if callback_data.startswith("tagprev_"):
        current_index = max(0, current_index - 1)
    elif callback_data.startswith("tagnext_"):
        current_index = min(len(results) - 1, current_index + 1)
    context.user_data['search_index'] = current_index
    entry = results[current_index]
    caption = (
        f"<b>ID:</b> {entry['id']}\n"
        f"<b>üë§ –ê–≤—Ç–æ—Ä—ã:</b> {', '.join(entry['authors'])}\n"
        f"<b>üè∑Ô∏è –¢–µ–≥–∏:</b> {', '.join(entry['tags'])}\n"
        f"<b>üë• –ü–µ—Ä—Å–æ–Ω–∞–∂–∏:</b> {', '.join(entry['characters'])}"
    )
    try:
        await query.edit_message_media(
            media=InputMediaPhoto(open(entry['file_path'], 'rb'), caption=caption, parse_mode="HTML"),
            reply_markup=create_navigation_buttons(current_index, len(results), prefix='tag')
        )
    except FileNotFoundError:
        await query.edit_message_text(f"‚ùå –§–æ—Ç–æ–≥—Ä–∞—Ñ–∏—è —Å ID {entry['id']} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ.")
    except Exception as e:
        await query.edit_message_text(f"‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏: {str(e)}")


# –ö–æ–º–∞–Ω–¥–∞ /search_character
async def search_character(update: Update, context: CallbackContext) -> None:
    await update.message.reply_text("üîç –í–≤–µ–¥–∏—Ç–µ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞ –¥–ª—è –ø–æ–∏—Å–∫–∞:")
    return "search_character"


async def search_character_result(update: Update, context: CallbackContext) -> int:
    character = update.message.text
    results = db.search_by_character(character)
    if results:
        context.user_data['search_results'] = results
        context.user_data['search_index'] = 0
        entry = results[0]
        caption = (
            f"<b>ID:</b> {entry['id']}\n"
            f"<b>üë§ –ê–≤—Ç–æ—Ä—ã:</b> {', '.join(entry['authors'])}\n"
            f"<b>üè∑Ô∏è –¢–µ–≥–∏:</b> {', '.join(entry['tags'])}\n"
            f"<b>üë• –ü–µ—Ä—Å–æ–Ω–∞–∂–∏:</b> {', '.join(entry['characters'])}"
        )
        try:
            await update.message.reply_photo(
                photo=open(entry['file_path'], 'rb'),
                caption=caption,
                parse_mode="HTML",
                reply_markup=create_navigation_buttons(0, len(results), prefix='character')
            )
        except FileNotFoundError:
            await update.message.reply_text(f"‚ùå –§–æ—Ç–æ–≥—Ä–∞—Ñ–∏—è —Å ID {entry['id']} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ.")
    else:
        await update.message.reply_text(f"‚ùå –ó–∞–ø–∏—Å–µ–π —Å –ø–µ—Ä—Å–æ–Ω–∞–∂–µ–º '{character}' –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.")


async def character_button_handler(update: Update, context: CallbackContext) -> None:
    query = update.callback_query
    await query.answer()
    results = context.user_data.get('search_results', [])
    if not results:
        await query.edit_message_text("‚ùå –û—à–∏–±–∫–∞: —Å–ø–∏—Å–æ–∫ –∑–∞–ø–∏—Å–µ–π –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω.")
        return
    current_index = context.user_data.get('search_index', 0)
    callback_data = query.data
    if callback_data.startswith("characterprev_"):
        current_index = max(0, current_index - 1)
    elif callback_data.startswith("characternext_"):
        current_index = min(len(results) - 1, current_index + 1)
    context.user_data['search_index'] = current_index
    entry = results[current_index]
    caption = (
        f"<b>ID:</b> {entry['id']}\n"
        f"<b>üë§ –ê–≤—Ç–æ—Ä—ã:</b> {', '.join(entry['authors'])}\n"
        f"<b>üè∑Ô∏è –¢–µ–≥–∏:</b> {', '.join(entry['tags'])}\n"
        f"<b>üë• –ü–µ—Ä—Å–æ–Ω–∞–∂–∏:</b> {', '.join(entry['characters'])}"
    )
    try:
        await query.edit_message_media(
            media=InputMediaPhoto(open(entry['file_path'], 'rb'), caption=caption, parse_mode="HTML"),
            reply_markup=create_navigation_buttons(current_index, len(results), prefix='character')
        )
    except FileNotFoundError:
        await query.edit_message_text(f"‚ùå –§–æ—Ç–æ–≥—Ä–∞—Ñ–∏—è —Å ID {entry['id']} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ.")
    except Exception as e:
        await query.edit_message_text(f"‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏: {str(e)}")


# –ö–æ–º–∞–Ω–¥–∞ /display
async def display_entries(update: Update, context: CallbackContext) -> None:
    entries = db.get_entries()
    if not entries:
        await update.message.reply_text("‚ùå –í –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö –Ω–µ—Ç –∑–∞–ø–∏—Å–µ–π.")
        return

    # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø–µ—Ä–≤–æ–µ —Ñ–æ—Ç–æ —Å –∫–Ω–æ–ø–∫–∞–º–∏
    entry = entries[0]
    caption = (
        f"<b>ID:</b> {entry['id']}\n"
        f"<b>üë§ –ê–≤—Ç–æ—Ä—ã:</b> {', '.join(entry['authors'])}\n"
        f"<b>üè∑Ô∏è –¢–µ–≥–∏:</b> {', '.join(entry['tags'])}\n"
        f"<b>üë• –ü–µ—Ä—Å–æ–Ω–∞–∂–∏:</b> {', '.join(entry['characters'])}"
    )
    try:
        context.user_data['current_index'] = 0  # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–µ–∫—É—â–∏–π –∏–Ω–¥–µ–∫—Å
        context.user_data['display_entries'] = entries  # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–ø–∏—Å–æ–∫ –∑–∞–ø–∏—Å–µ–π
        await update.message.reply_photo(
            photo=open(entry['file_path'], 'rb'),
            caption=caption,
            parse_mode="HTML",
            reply_markup=create_navigation_buttons(0, len(entries))
        )
    except FileNotFoundError:
        await update.message.reply_text(f"‚ùå –§–æ—Ç–æ–≥—Ä–∞—Ñ–∏—è —Å ID {entry['id']} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ.")
    except Exception as e:
        await update.message.reply_text(f"‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–∏ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏: {str(e)}")


# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–æ–∫ –ø—Ä–æ–ª–∏—Å—Ç—ã–≤–∞–Ω–∏—è
async def button_handler(update: Update, context: CallbackContext) -> None:
    query = update.callback_query
    await query.answer()  # –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–∞–µ–º –ø–æ–ª—É—á–µ–Ω–∏–µ callback

    entries = context.user_data.get('display_entries', [])
    if not entries:
        await query.edit_message_text("‚ùå –û—à–∏–±–∫–∞: —Å–ø–∏—Å–æ–∫ –∑–∞–ø–∏—Å–µ–π –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω.")
        return

    current_index = context.user_data.get('current_index', 0)
    callback_data = query.data

    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –Ω–æ–≤—ã–π –∏–Ω–¥–µ–∫—Å
    try:
        if callback_data.startswith("prev_"):
            current_index = max(0, current_index - 1)
        elif callback_data.startswith("next_"):
            current_index = min(len(entries) - 1, current_index + 1)
    except ValueError:
        await query.edit_message_text("‚ùå –û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –∫–Ω–æ–ø–∫–∏.")
        return

    context.user_data['current_index'] = current_index
    entry = entries[current_index]

    caption = (
        f"<b>ID:</b> {entry['id']}\n"
        f"<b>üë§ –ê–≤—Ç–æ—Ä—ã:</b> {', '.join(entry['authors'])}\n"
        f"<b>üè∑Ô∏è –¢–µ–≥–∏:</b> {', '.join(entry['tags'])}\n"
        f"<b>üë• –ü–µ—Ä—Å–æ–Ω–∞–∂–∏:</b> {', '.join(entry['characters'])}"
    )

    try:
        # –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –Ω–æ–≤—ã–º —Ñ–æ—Ç–æ –∏ –∫–Ω–æ–ø–∫–∞–º–∏
        await query.edit_message_media(
            media=InputMediaPhoto(open(entry['file_path'], 'rb'), caption=caption, parse_mode="HTML"),
            reply_markup=create_navigation_buttons(current_index, len(entries))
        )
    except FileNotFoundError:
        await query.edit_message_text(f"‚ùå –§–æ—Ç–æ–≥—Ä–∞—Ñ–∏—è —Å ID {entry['id']} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ.")
    except Exception as e:
        await query.edit_message_text(f"‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏: {str(e)}")


# –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–æ–∫ –ø—Ä–æ–ª–∏—Å—Ç—ã–≤–∞–Ω–∏—è –ø–æ –∞–≤—Ç–æ—Ä–∞–º
async def author_button_handler(update: Update, context: CallbackContext) -> None:
    query = update.callback_query
    await query.answer()
    results = context.user_data.get('search_results', [])
    if not results:
        await query.edit_message_text("‚ùå –û—à–∏–±–∫–∞: —Å–ø–∏—Å–æ–∫ –∑–∞–ø–∏—Å–µ–π –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω.")
        return
    current_index = context.user_data.get('search_index', 0)
    callback_data = query.data
    if callback_data.startswith("authorprev_"):
        current_index = max(0, current_index - 1)
    elif callback_data.startswith("authornext_"):
        current_index = min(len(results) - 1, current_index + 1)
    context.user_data['search_index'] = current_index
    entry = results[current_index]
    caption = (
        f"<b>ID:</b> {entry['id']}\n"
        f"<b>üë§ –ê–≤—Ç–æ—Ä—ã:</b> {', '.join(entry['authors'])}\n"
        f"<b>üè∑Ô∏è –¢–µ–≥–∏:</b> {', '.join(entry['tags'])}\n"
        f"<b>üë• –ü–µ—Ä—Å–æ–Ω–∞–∂–∏:</b> {', '.join(entry['characters'])}"
    )
    try:
        await query.edit_message_media(
            media=InputMediaPhoto(open(entry['file_path'], 'rb'), caption=caption, parse_mode="HTML"),
            reply_markup=create_navigation_buttons(current_index, len(results), prefix='author')
        )
    except FileNotFoundError:
        await query.edit_message_text(f"‚ùå –§–æ—Ç–æ–≥—Ä–∞—Ñ–∏—è —Å ID {entry['id']} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ.")
    except Exception as e:
        await query.edit_message_text(f"‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏: {str(e)}")


# –ö–æ–º–∞–Ω–¥–∞ /cancel
async def cancel(update: Update, context: CallbackContext) -> int:
    await update.message.reply_text(
        "–û–ø–µ—Ä–∞—Ü–∏—è –æ—Ç–º–µ–Ω–µ–Ω–∞.",
        reply_markup=create_command_menu()
    )
    return ConversationHandler.END


# –ö–æ–º–∞–Ω–¥–∞ /help
async def help_command(update: Update, context: CallbackContext) -> None:
    await update.message.reply_text(
        "üåü <b>–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:</b>\n\n"
        "/add - –î–æ–±–∞–≤–∏—Ç—å –Ω–æ–≤—É—é —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏—é\n"
        "/update - –û–±–Ω–æ–≤–∏—Ç—å –∑–∞–ø–∏—Å—å\n"
        "/search_author - –ù–∞–π—Ç–∏ –ø–æ –∞–≤—Ç–æ—Ä—É\n"
        "/search_tag - –ù–∞–π—Ç–∏ –ø–æ —Ç–µ–≥—É\n"
        "/search_character - –ù–∞–π—Ç–∏ –ø–æ –ø–µ—Ä—Å–æ–Ω–∞–∂—É\n"
        "/display - –ü–æ–∫–∞–∑–∞—Ç—å –≤—Å–µ –∑–∞–ø–∏—Å–∏\n"
        "/help - –ü–æ–∫–∞–∑–∞—Ç—å —Å–ø–∏—Å–æ–∫ –∫–æ–º–∞–Ω–¥",
        parse_mode="HTML",
        reply_markup=create_command_menu()
    )


def main() -> None:
    # –°–æ–∑–¥–∞–µ–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –¥–ª—è —Ñ–æ—Ç–æ
    os.makedirs('photos', exist_ok=True)

    # –°–æ–∑–¥–∞–µ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ —Å —Ç–æ–∫–µ–Ω–æ–º
    application = Application.builder().token(TOKEN).build()

    # –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /start
    application.add_handler(CommandHandler("start", start))

    # –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /add
    add_conversation_handler = ConversationHandler(
        entry_points=[CommandHandler('add', add_entry)],
        states={
            ADD_PHOTO: [MessageHandler(filters.PHOTO, add_photo)],
            ADD_AUTHORS: [MessageHandler(filters.TEXT & ~filters.COMMAND, add_authors)],
            ADD_TAGS: [MessageHandler(filters.TEXT & ~filters.COMMAND, add_tags)],
            ADD_CHARACTERS: [MessageHandler(filters.TEXT & ~filters.COMMAND, add_characters)],
        },
        fallbacks=[CommandHandler('cancel', cancel)],
    )
    application.add_handler(add_conversation_handler)

    # –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /update
    update_conversation_handler = ConversationHandler(
        entry_points=[CommandHandler('update', update_entry)],
        states={
            UPDATE_ID: [MessageHandler(filters.TEXT & ~filters.COMMAND, update_id)],
            UPDATE_AUTHORS: [MessageHandler(filters.TEXT & ~filters.COMMAND, update_authors),
                             CommandHandler('skip', update_authors_skip)],
            UPDATE_TAGS: [MessageHandler(filters.TEXT & ~filters.COMMAND, update_tags),
                          CommandHandler('skip', update_tags_skip)],
            UPDATE_CHARACTERS: [MessageHandler(filters.TEXT & ~filters.COMMAND, update_characters),
                                CommandHandler('skip', update_characters_skip)],
        },
        fallbacks=[CommandHandler('cancel', cancel)],
    )
    application.add_handler(update_conversation_handler)

    # –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /search_author
    search_author_conversation_handler = ConversationHandler(
        entry_points=[CommandHandler('search_author', search_author)],
        states={
            0: [MessageHandler(filters.TEXT & ~filters.COMMAND, search_author_result)],
        },
        fallbacks=[CommandHandler('cancel', cancel)],
    )
    application.add_handler(search_author_conversation_handler)

    # –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /search_tag
    search_tag_conversation_handler = ConversationHandler(
        entry_points=[CommandHandler('search_tag', search_tag)],
        states={
            "search_tag": [MessageHandler(filters.TEXT & ~filters.COMMAND, search_tag_result)],
        },
        fallbacks=[CommandHandler('cancel', cancel)],
    )
    application.add_handler(search_tag_conversation_handler)

    # –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /search_character
    search_character_conversation_handler = ConversationHandler(
        entry_points=[CommandHandler('search_character', search_character)],
        states={
            "search_character": [MessageHandler(filters.TEXT & ~filters.COMMAND, search_character_result)],
        },
        fallbacks=[CommandHandler('cancel', cancel)],
    )
    application.add_handler(search_character_conversation_handler)

    # –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /display
    application.add_handler(CommandHandler("display", display_entries))

    # –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–æ–∫ –ø—Ä–æ–ª–∏—Å—Ç—ã–≤–∞–Ω–∏—è
    application.add_handler(CallbackQueryHandler(button_handler, pattern="^(prev|next)_"))

    # –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–æ–∫ –ø—Ä–æ–ª–∏—Å—Ç—ã–≤–∞–Ω–∏—è –ø–æ –∞–≤—Ç–æ—Ä–∞–º
    application.add_handler(CallbackQueryHandler(author_button_handler, pattern="^author(prev|next)_"))

    # –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–æ–∫ –ø—Ä–æ–ª–∏—Å—Ç—ã–≤–∞–Ω–∏—è –ø–æ —Ç–µ–≥–∞–º
    application.add_handler(CallbackQueryHandler(tag_button_handler, pattern="^tag(prev|next)_"))

    # –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–æ–∫ –ø—Ä–æ–ª–∏—Å—Ç—ã–≤–∞–Ω–∏—è –ø–æ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞–º
    application.add_handler(CallbackQueryHandler(character_button_handler, pattern="^character(prev|next)_"))

    # –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /help
    application.add_handler(CommandHandler("help", help_command))

    # –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞
    application.run_polling()


if __name__ == "__main__":

    main()
